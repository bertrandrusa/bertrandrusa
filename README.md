### Hi there ðŸ‘‹, my name is Bertrand
#### Student to design and develop
![Student to design and develop](https://media.licdn.com/dms/image/D4D16AQHMim12AgDmBQ/profile-displaybackgroundimage-shrink_350_1400/0/1687419373915?e=1721865600&v=beta&t=VQUDzHDkKE6e9FmDnJn80VRbrPTEYcia-ptnCMlQdcI)

I am a student at Missouri State University, pursuing a Bachelor of Science in Computer Science and Mathematics. I have a big passion for technology and a strong desire to make a meaningful impact. While anyone can learn to code, my goal is to become a problem solver who uses technology to address real-world challenges.
 ## "DO WHAT YOU LOVE, LOVE WHAT YOU DO."
## Skills
ðŸ’» C++ / python / HTML / CSS/Javascript

- ðŸ”­ Iâ€™m currently working on  couple projects 


[<img src='https://cdn.jsdelivr.net/npm/simple-icons@3.0.1/icons/linkedin.svg' alt='linkedin' height='40'>](https://www.linkedin.com/in/bertrand-rusanganwa-433607276/)  [<img src='https://cdn.jsdelivr.net/npm/simple-icons@3.0.1/icons/instagram.svg' alt='instagram' height='40'>](https://www.instagram.com/bertrand_rusa/)  

Hereâ€™s a focused cheat sheet for **Finite Automata** based on the difficult-to-remember parts from your slides:

---

Hereâ€™s the refined cheat sheet with **only answers**:

---

Hereâ€™s a cheat sheet focusing on the tricky parts of **interpreters** based on your slides:

---

### **1. Compiler vs Interpreter**
- **Pure Compiler**: Translates the entire program into machine code and then finishes. The program can be run directly on the hardware after compilation.
- **Pure Interpreter**: Stays active during the execution, reading and executing code line by line, which allows for greater flexibility and better error reporting at runtime.
- **Key Point**: A pure compiler tends to perform better, while an interpreter offers flexibility but slower execution due to real-time code execution.
### **2. Lexing and Scanning**
- **Lexer (Scanner)**: Breaks the source code into **tokens** (smallest meaningful units like keywords, operators, etc.).
- **Key Function**: The lexer simplifies processing by categorizing the source into tokens, which speeds up the parsing process later.
- **Example**: For a simple GCD program, the lexer groups statements like `int`, `while`, `if`, etc., into distinct tokens.
### **3. Parsing**
- **Parser**: Converts tokens from the lexer into a **parse tree** or an **abstract syntax tree (AST)**, representing the structure and semantics of the code.
- **Key Feature**: The parse tree is essential for understanding how different parts of the code relate to each other, which is critical for both interpretation and compilation.
- **Example**: A parser might take a tokenized expression like `x = 3` and convert it into a tree structure representing assignment.
### **4. Execution/Interpretation**
- **Tree-Walking**: The interpreter **"walks"** the parse tree generated by the parser to execute the program. It evaluates expressions and processes statements based on the tree's structure.
- **Key Feature**: This step involves "walking" the tree, checking each node, and executing the associated code.
- **Example**: For an expression `z = (x^2 + y^2)^0.5`, the interpreter would first evaluate `x^2`, `y^2`, then their sum, and finally the square root.
### **5. Types of Programming Languages**
- **Imperative Languages**: Focus on *how* the machine should perform tasks, using mutable state and commands (e.g., C, Python).
- **Object-Oriented Languages**: Group data and methods into objects, focusing on inheritance and encapsulation (e.g., C++, Java).
- **Declarative Languages**: Focus on *what* the program should accomplish, leaving the *how* to the underlying system (e.g., Prolog, SQL).
### **6. Compiler Phases**
- **Pre-Processing**: Removes comments, expands macros, and simplifies the code for further processing.
- **Lexical Analysis**: Breaks the source into tokens.
- **Parsing**: Converts tokens into a parse tree.
- **Semantic Analysis**: Ensures logical consistency and correctness of the parse tree (e.g., type checks).
- **Code Generation**: Produces assembly or machine code that the computer can execute.
- **Optimization**: Improves the efficiency of the generated code, reducing runtime or memory usage.
### **7. Intermediate Representation (IR)**
- **Purpose**: IR serves as a bridge between the high-level source code and the low-level machine code. Itâ€™s often used to perform optimizations before code generation.
- **Key Features**: IRs are machine-independent, compact, and often resemble machine code for an abstract machine.
### **8. Semantic Analysis**
- **Static Semantics**: Done during compilation; ensures correctness that can be checked at compile time (e.g., type mismatches, undeclared variables).
- **Dynamic Semantics**: Deals with errors that can only be detected at runtime (e.g., array bounds checking, division by zero).
### **9. Just-In-Time Compilation (JIT)**
 **JIT Compilation**: Combines interpretation and compilation. Code is compiled **at runtime** to optimize performance (e.g., Java Bytecode).
 **Benefit**: Delays compilation until the last moment, allowing for runtime optimizations.
### **10. Abstract Syntax Tree (AST)**
 **Key Feature**: The AST represents the hierarchical structure of the program, containing only the essential information for execution, ignoring formatting and comments.
 **Nodes**: Each node in the AST corresponds to a syntactic construct (e.g., assignment, expression).
